/*
 * The MIT License (MIT)
 * Copyright Â© 2022 James Parker
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal 
 * in the Software without restriction, including without limitation the rights 
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell 
 * copies of the Software, and to permit persons to whom the Software is 
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in 
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF 
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. 
 * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, 
 * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR 
 * OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE 
 * OR OTHER DEALINGS IN THE SOFTWARE.
 */

#pragma once

#include "../../porting/jude_porting.h"
#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif

/* Define this if your CPU architecture is big endian, i.e. it
 * stores the most-significant byte first. */
/* #define __BIG_ENDIAN__ 1 */

/* Enable support for error message buffers in order to give better diagnostics */
#define JUDE_ERRMSG_BUFFER_LEN 64

/* Controls how large masks and filters can get */
#define JUDE_MAX_FIELDS_PER_MESSAGE 64

#define jude_fatal(message) \
   jude_os->fatal(__FILE__, __LINE__, message)

#define jude_assert(condition) \
   do { if (!(condition)) { jude_fatal( #condition ); } } while (0)

#define JUDE_VERSION jude-0.1.1

#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>
#include <string.h>
#include <stdio.h>

#ifndef NULL
#define NULL ((void *)0)
#endif

/* Handly macro for suppressing unreferenced-parameter compiler warnings. */
#ifndef JUDE_UNUSED
#define JUDE_UNUSED(x) (void)(x)
#endif

/* Use the GCC warn_unused_result attribute to check that all return values
 * are propagated correctly. On other compilers and gcc before 3.4.0 just
 * ignore the annotation.
 */
#if !defined(__GNUC__) || ( __GNUC__ < 3) || (__GNUC__ == 3 && __GNUC_MINOR__ < 4)
#define checkreturn
#else
#define checkreturn __attribute__((warn_unused_result))
#endif

/* Compile-time assertion, used for checking compatible compilation options.
 * If this does not work properly on your compiler, use
 * #define JUDE_NO_STATIC_ASSERT to disable it.
 *
 * But before doing that, check carefully the error message / place where it
 * comes from to see if the error has a real cause. Unfortunately the error
 * message is not always very clear to read, but you can see the reason better
 * in the place where the JUDE_STATIC_ASSERT macro was called.
 */
#ifndef JUDE_NO_STATIC_ASSERT
#ifndef JUDE_STATIC_ASSERT
#define JUDE_STATIC_ASSERT(COND,MSG) typedef char JUDE_STATIC_ASSERT_MSG(MSG, __LINE__, __COUNTER__)[(COND)?1:-1];
#define JUDE_STATIC_ASSERT_MSG(MSG, LINE, COUNTER) JUDE_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER)
#define JUDE_STATIC_ASSERT_MSG_(MSG, LINE, COUNTER) jude_static_assertion_##MSG##LINE##COUNTER
#endif
#else
#define JUDE_STATIC_ASSERT(COND,MSG)
#endif

/* Number of required fields to keep track of. */
#ifndef JUDE_MAX_REQUIRED_FIELDS
#define JUDE_MAX_REQUIRED_FIELDS 64
#endif

#if JUDE_MAX_REQUIRED_FIELDS < 64
#error You should not lower JUDE_MAX_REQUIRED_FIELDS from the default value (64).
#endif

/* List of optional field types. These are used in the autogenerated code.
 * Least-significant 4 bits tell the scalar type
 * Most-significant 4 bits specify repeated/required/packed etc.
 */

typedef enum {
   JUDE_TYPE_BOOL,
   JUDE_TYPE_SIGNED,
   JUDE_TYPE_UNSIGNED,
   JUDE_TYPE_FLOAT,
   JUDE_TYPE_ENUM,
   JUDE_TYPE_BITMASK,
   JUDE_TYPE_STRING,
   JUDE_TYPE_BYTES,
   JUDE_TYPE_OBJECT,
   JUDE_TYPE_NULL
} jude_type_t;

/**** Field data types ****/

#define JUDE_JTYPE(x) ((x) & JUDE_JTYPE_MASK)
#define JUDE_LTYPE(x) ((x) & JUDE_LTYPE_MASK)
#define JUDE_IS_JSON_BITMASK(x) ((x) & JUDE_JSON_BITMASK)

/* Data type used for storing:
 *   1. sizes of struct fields
 *   2. value of array index
 *   3. array counts
 *   4. field indeces
 */
#define JUDE_SIZE_MAX ((uint16_t)-1)
#define JUDE_MAX_UNKNOWN_FIELD_LENGTH (4096)

typedef uint32_t jude_size_t;
typedef int32_t jude_ssize_t;

typedef uint16_t jude_index_t;

#ifndef JUDE_ID_SIZE
#define JUDE_ID_SIZE 32
#endif

#if (JUDE_ID_SIZE == 64)
typedef uint64_t jude_id_t;
#define PRIjudeID  PRIu64
#define PRIjudeIDx "016" PRIx64
#define SCNjudeID  SCNu64
#elif (JUDE_ID_SIZE == 32)
typedef uint32_t jude_id_t;
#define PRIjudeID  PRIu32
#define PRIjudeIDx "08" PRIx32
#define SCNjudeID  SCNu32
#elif (JUDE_ID_SIZE == 16)
typedef uint16_t jude_id_t;
#define PRIjudeID  PRIu16
#define PRIjudeIDx "04" PRIx16
#define SCNjudeID  SCNu16
#else
#error "Invalid JUDE_ID_SIZE: " JUDE_ID_SIZE
#endif

/* Make sure that the standard integer types are of the expected sizes.
 * All kinds of things may break otherwise.. atleast all fixed* types.
 *
 * If you get errors here, it probably means that your stdint.h is not
 * correct for your platform.
 */
JUDE_STATIC_ASSERT(sizeof(int8_t) == 1, INT8_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(uint8_t) == 1, UINT8_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(int16_t) == 2, INT16_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(uint16_t) == 2, UINT16_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(int32_t) == 4, INT32_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(uint32_t) == 4, UINT32_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(int64_t) == 8, INT64_T_WRONG_SIZE)
JUDE_STATIC_ASSERT(sizeof(uint64_t) == 8, UINT64_T_WRONG_SIZE)

/* This structure is used for 'bytes' arrays.
 * It has the number of bytes in the beginning, and after that an array.
 * Note that actual structs used will have a different length of bytes array.
 */
#define JUDE_BYTES_ARRAY_T(n) struct { jude_size_t size; uint8_t bytes[n]; }
#define JUDE_BYTES_ARRAY_T_ALLOCSIZE(n) ((size_t)n + offsetof(jude_bytes_array_t, bytes))

struct jude_bytes_array_t
{
   jude_size_t size;
   uint8_t bytes[1];
};

#define JUDE_PROTO_HEADER_VERSION 30

/* These macros are used to declare jude_field_t's in the constant array. */
/* Size of a structure member, in bytes. */
#define jude_membersize(st, m) ((jude_size_t)(sizeof((st*)0)->m))
/* Number of entries in an array. */
#define jude_arraysize(st, m) ((jude_size_t)(jude_membersize(st, m) / jude_membersize(st, m[0])))
/* Delta from start of one member to the start of another member. */
#define jude_delta(st, m1, m2) ((jude_ssize_t)offsetof(st, m1) - (jude_ssize_t)offsetof(st, m2))
/* Marks the end of the field list */
#define JUDE_LAST_FIELD \
   {                  \
     .label = NULL,   \
     .tag = 0         \
   }

/* Macros for filling in the data_offset field */
/* data_offset for first field in a message */
#define JUDE_DATAOFFSET_FIRST(st, m1, m2) (offsetof(st, m1))
/* data_offset for subsequent fields */
#define JUDE_DATAOFFSET_OTHER(st, m1, m2) (offsetof(st, m1) - offsetof(st, m2) - jude_membersize(st, m2))

/*
 * Each generted structure begins with a variable length uint8_t array - each bit in the array
 * is to denote whether a corresponding tag is set or not.
 * Each field has a bit regardless of whether that field is "required" or not.
 */
#define JUDE_UNKNOWN_ARRAY_INDEX ((jude_size_t)(-1))
#define JUDE_UNKNOWN_FIELD_INDEX ((unsigned char)(-1))
#define JUDE_ID_FIELD_INDEX      ((unsigned char)(0)) // for speed, "id" field is always bit 0
#define JUDE_INVALID_ID          ((jude_id_t)(-2))
#define JUDE_AUTO_ID             ((jude_id_t)(-1))

#define JUDE_TAG_UNKNOWN             0
#define JUDE_TAG_UNKNOWN_BUT_HANDLED ((jude_size_t)(-1))     // special value used for telling upper level that we have handled an unknown tag

typedef enum
{
   jude_user_Open    = 0,  // anyone (even unauthenticated users) over the API
   jude_user_Public  = 1,  // authenticated users over the API
   jude_user_Cloud   = 2,  // cloud based interactions (slightly higher access that Public)
   jude_user_Admin   = 3,  // trusted user over the API (e.g. internal processes, CLI)
   jude_user_Root    = 4   // internal code only
} jude_user_t;

// Forward declarations...
typedef struct jude_rtti_t jude_rtti_t;
typedef struct jude_object_t jude_object_t;
typedef struct jude_istream_t jude_istream_t;
typedef struct jude_ostream_t jude_ostream_t;
typedef struct jude_callback_t jude_callback_t;
typedef struct jude_enum_map_t jude_enum_map_t;
typedef struct jude_enum_map_t jude_bitmask_map_t;
typedef struct jude_field_t jude_field_t;
typedef struct jude_bytes_array_t jude_bytes_array_t;
typedef struct jude_subscriber_t jude_subscriber_t;
typedef struct jude_notification_t jude_notification_t;
typedef struct jude_notification_queue_t jude_notification_queue_t;
typedef union  jude_filter_t jude_filter_t;
typedef struct jude_iterator_t jude_iterator_t;
typedef struct jude_encode_transport_t jude_encode_transport_t;
typedef struct jude_decode_transport_t jude_decode_transport_t;

#ifdef __cplusplus
namespace jude
{
   namespace Options
   {
      // If set to true (default), then we ensure that collection is an object with id as "key" and resources as "value".
      // If set to false, we just serialise as an array of JSON objects
      extern bool SerialiseCollectionAsObjectMap;

      // Useful for testing - forces all changes to be published immediately 
      // By default we would wait until the edit was completed before publishing
      extern bool NotifyImmediatelyOnChange; 

      // When creating a new entry in a collection, should we validate only when this has been
      // Done over the REST API (default) or even just if we create "in code"?
      extern bool ValidatePostOnlyForRestAPI; 

      // When creating a new entry in a collection, should we validate only when this has been
      // Done over the REST API (default) or even just if we create "in code"?
      extern jude_user_t DefaultAccessLevelForJSON; 
   }
}
#endif

jude_object_t *jude_remove_const(const jude_object_t *pointer);

void jude_init(); // initialise the entire jude subsystem
void jude_shutdown(); // shutdown the jude subsystem

typedef jude_id_t (*jude_uuid_generator)(void *user_data);

jude_id_t jude_generate_uuid();
// For testing purposes, we can override how UUID's are generated
jude_uuid_generator jude_install_custom_uuid_geneartor(void* user_data, jude_uuid_generator generator_function);

#ifdef __cplusplus
}
#endif
